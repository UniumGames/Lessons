### Создание префаба с помощью скрипта

Некоторые игры имеют постоянное количество объектов на сцене, однако обычно персонажи, пули, сокровища и другие объекты создаются и удаляются во время игры. В Unity, игровой объект (`GameObject`) может быть создан через функцию `Instantiate`, которая делает копию существующего объекта. Объект, который мы будем клонировать, должен быть префабом и сохранен в папке `Resources` (папка должна называться именно так).

```csharp
public GameObject enemy;

void Start() {
    // создаем три копии врага
    Instantiate(enemy);
    Instantiate(enemy);
    Instantiate(enemy);
}
```

Существует версия `Instantiate`, которая позволяет сразу задать положение и поворот клона

```csharp
public GameObject enemy;

void Start() {
    // сохраняем координаты (10, 0, 0)
    Vector3 position = new Vector3(10, 0, 0);
    // сохраняем угол 30 градусов
    Quaternion rotation = Quaternion.Euler(new Vector3(0, 30, 0));
    Instantiate(enemy, position, rotation);
}
```

И, наконец, можно сохранить клон (или его компонент) в переменную, чтобы его дополнительно настроить. Тип нужного компонента указывается в угловых скобках

```csharp
public GameObject enemy;

void Start() {
    // сохраним клон в переменную clone
    Rigidbody clone = Instantiate<Rigidbody>(enemy);
    // изменим массу клона
    clone.mass = 10;
}
```

### Обработка столкновений

Часто нам нужно выполнить какое-то действие при столкновении объектов в игре: засчитать очки при попадании пули во врага, проиграть анимацию сжатия, когда мяч падает на землю, отрисовать вмятины при столкновении машин, проигрывать звук при ударе мяча о биту и тд

Для обработки столкновений скрипт получает события `OnCollisionEnter`, `OnCollisionStay` и `OnCollisionExit`. Работа с ними полностью аналогична работе с событиями триггеров.

- Событие `OnCollisionEnter` будет посылаться, когда объекты только начали касаться друг друга
- `OnCollisionExit `, когда объекты только перестали касаться друг друга
- `OnCollisionStay `, пока объекты касаются друг друга

Обрати внимание, что:

- События столкновений срабатывают только для объектов, у которых есть коллайдер и параметр `Is Trigger` отключен
- В событие столкновения параметром передается объект типа `Collision`, а не `Collider`. Из этого объекта можно получить объект, с которым произошло столкновение, и другие данные о столкновении

```csharp
void OnCollisionEnter(Collision collision) {
	// сохраним объект, с которым произошло столкновение
	GameObject other = collision.gameObject;
	// и выведем его имя
	print(other.name);
}
```

### Удаление объектов

Также есть функция `Destroy`, которая уничтожит объект после того, как загрузка кадра будет завершена или опционально после паузы:

```csharp
void OnTriggerEnter(Collider other) {
    // если столкнулись с объектом с тегом Снаряд
    if (other.tag == "Missile") {
        // то самоуничтожаемся через секунду
        Destroy(gameObject, 1);
    }
}
```

### Система ввода. Чтение клавиш

Система ввода — это взаимодействие между игрой и игроком. Устройством ввода может быть клавиатура, мышь, джойстик, руль, геймпад и прочие устройства.

Для работы с клавиатурой в классе `Input` есть несколько статических методов

- `Input.GetKey()` проверяет, что кнопка удерживается
- `Input.GetKeyDown()` проверяет, что кнопку только что нажали
- `Input.GetKeyUp()` проверяет, что кнопку отпустили

Эти методы принимают параметром либо строку с именем клавиши, либо константу класса `KeyCode`. Второй вариант обычно удобнее

```csharp
void Update() {
    // передаем в GetKey строку с именем клавиши
    if (Input.GetKey("up")){
        print("Клавиша вверх зажата");
    }

    // передаем в GetKey константу из KeyCode
    if (Input.GetKey(KeyCode.DownArrow)){
        print("Клавиша вниз зажата");
    }
}
```

### Получение имени объекта

Часто нужно узнать в скрипте имя объекта. Например, когда какой-то объект вошел в зону триггера. Чтобы узнать имя объекта, проверяй поле `name` этого объекта. 

Например, так можно проверить, что объект, хранящийся в переменной `model` имеет имя `Bullet`

```csharp
if (model.name == "Bullet") {
	// объект с именем Bullet
}
```

### Получение тега объекта

Если мы создаем копию объекта из префаба, то его имя НЕ будет совпадать с именем оригинала. В этом случае нам следует добавить объекту тег и определять объект по нему. У всех копий префаба будет одинаковый тег

```csharp
if (model.tag == "Bullet") {
	// объект с тегом Bullet
}
```

### Создание нового тега

Инспектор отображает выпадающее меню с тегами прямо под именем игрового объекта. Чтобы создать новый тег, выберите в выпадающем меню пункт `Add Tag`. Откроется `Tag and Layer Manager`.

![img](https://docs.unity3d.com/uploads/Main/TagDropdown.png)

Кликните кнопку с плюсом в нижнем правом углу списка тегов и введите имя вашего нового тега.

![Adding a new Tag](https://docs.unity3d.com/uploads/Main/TagManagerAddNew.png)

### Добавление звука с помощью скрипта

Звуки часто должны воспроизводиться в зависимости от определенного события. Например, нажав на определенную кнопку автомобиль издает звук гудка. Вот другой пример: если персонаж входит в определенную зону — звучит звук ветра.

Настрой `Audio Source` так, как было описано в [занятии 3](http://unity3d.unium.ru/lessons/lesson3/index.html#addsound). При  этом отключи опцию `Play on Awake` (проиграть при старте), так как мы будем запускать проигрывание клипа из скрипта

```csharp
// при срабатывании триггера
void OnTriggerEnter(Collider other) {
	// получаем компонент AudioSource
	AudioSource audio = GetComponent<AudioSource>();
	// и проигрываем добавленный в него звук
	audio.Play();
}
```